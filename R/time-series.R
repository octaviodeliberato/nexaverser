# GENERATED BY RFOLD: DO NOT EDIT BY HAND ####
#' cluster_ts
#'
#' @param .tag_dat A time series with `date` and `value` cols.
#' @param .clusters The number of clusters.
#'
#' @return A list.
#' @export
#'
cluster_ts <- function(
    .tag_dat,
    .clusters
) {

  full_data_tbl <- .tag_dat |>
    tidyr::pivot_longer(-date)

  # clustering process
  tsfeature_tbl <- full_data_tbl |>
    dplyr::group_by(name) |>
    timetk::tk_tsfeatures(
      .date_var = date,
      .value    = value,
      .period   = "day",
      .features = c("frequency", "stl_features", "entropy", "acf_features",
                    "my_mean"),
      .scale    = TRUE,
      .prefix   = "ts_"
    ) |>
    dplyr::ungroup()

  set.seed(123)

  cluster_tbl <- tibble::tibble(
    cluster = tsfeature_tbl |>
      dplyr::select(-name) |>
      dplyr::mutate_all(tidyr::replace_na, 0) |>
      as.matrix() |>
      stats::kmeans(centers = .clusters, nstart = 100) |>
      purrr::pluck("cluster")
  ) |>
    dplyr::bind_cols(
      tsfeature_tbl
    )

  cluster_lookup_tbl <- cluster_tbl |>
    dplyr::select(name, cluster) |>
    dplyr::arrange(name)

  full_data_tbl$cluster <- rep(1, nrow(full_data_tbl))

  full_data_tbl$cluster <- full_data_tbl |>
    dplyr::select(name) |>
    as.vector() |>
    sapply(
      \(x) {
        tidyquant::VLOOKUP(
          .lookup_values = x,
          .data          = cluster_lookup_tbl,
          .lookup_column = name,
          .return_column = cluster
        )
      }
    ) |>
    as.numeric()

  return(
    full_data_tbl |>
      purrr::set_names(c("date", "tag", "value", "cluster")) |>
      split(~cluster)
  )

}


# calibrate_and_plot
#
calibrate_and_plot <- function(..., .splits, .actual_data,
                               .show_ci = FALSE, type = "testing") {

  if (type == "testing") {
    new_data <- rsample::testing(.splits)
  } else {
    new_data <- rsample::training(.splits) |> tidyr::drop_na()
  }

  calibration_tbl <- modeltime::modeltime_table(...) |>
    modeltime::modeltime_calibrate(new_data)

  acc_tbl <- calibration_tbl |> modeltime::modeltime_accuracy()

  fore_dat <- calibration_tbl |>
    modeltime::modeltime_forecast(
      new_data    = new_data,
      actual_data = .actual_data
    )

  fore_plt <- fore_dat |>
    modeltime::plot_modeltime_forecast(.conf_interval_show = .show_ci)

  return(
    list(
      calibration = calibration_tbl,
      metrics     = acc_tbl,
      forecast    = list(data = fore_dat, plot = fore_plt)
    )
  )

}


#' forecast_prophet
#'
#' @param .tag_dat A time series with `date` and `value` cols.
#' @param .assess The number of samples used for each assessment resample.
#' @param .horiz The forecast horizon.
#'
#' @return A `parsnip` (PROPHET) model object.
#' @export
#'
forecast_prophet <- function(
  .tag_dat,
  .assess = 1,
  .horiz  = 1
) {

  splits <- timetk::time_series_split(
    data       = .tag_dat,
    date_var   = date,
    assess     = .assess,
    cumulative = TRUE
  )

  model_fit_prophet <- modeltime::prophet_reg() |>
    parsnip::set_engine("prophet") |>
    parsnip::fit(value ~ date, data = rsample::training(splits))

  output <- calibrate_and_plot(model_fit_prophet, .splits = splits,
                               .actual_data = .tag_dat)

  model_refit_prophet <- output$calibration |>
    modeltime::modeltime_refit(data = .tag_dat)

  fore_dat <- model_refit_prophet |>
    modeltime::modeltime_forecast(
      h = .horiz,
      actual_data = .tag_dat
    )

  fore_plt <- fore_dat |>
    modeltime::plot_modeltime_forecast(
      .conf_interval_show = TRUE
    )

  attr(output, "model_fit")   <- model_fit_prophet
  attr(output, "model_refit") <- model_refit_prophet
  attr(output, "forecast")    <- fore_dat
  attr(output, "plot")        <- fore_plt

  return(output)

}


#' forecast_nnetar
#'
#' @param .tag_dat A time series with `date` and `value` cols.
#' @param .assess The number of samples used for each assessment resample.
#' @param .horiz The forecast horizon.
#' @param .seasonal_period A seasonal frequency. Uses "auto" by default. A
#' character phrase of "auto" or time-based phrase of "2 weeks" can be used if
#' a date or date-time variable is provided.
#'
#' @return A `parsnip` (NNAR) model object.
#' @export
#'
forecast_nnetar <- function(
    .tag_dat,
    .assess = 1,
    .horiz  = 1,
    .seasonal_period = "auto"
) {

  splits <- timetk::time_series_split(
    data       = .tag_dat,
    date_var   = date,
    assess     = .assess,
    cumulative = TRUE
  )

  set.seed(123)
  model_fit_nnetar <- modeltime::nnetar_reg(
    seasonal_period = .seasonal_period,
    hidden_units    = 10,
    penalty         = 10,
    num_networks    = 10,
    epochs          = 100
  ) |>
    parsnip::set_engine("nnetar") |>
    parsnip::fit(value ~ date, rsample::training(splits))

  output <- calibrate_and_plot(model_fit_nnetar, .splits = splits,
                               .actual_data = .tag_dat)

  model_refit_nnetar <- output$calibration |>
    modeltime::modeltime_refit(data = .tag_dat)

  fore_dat <- model_refit_nnetar |>
    modeltime::modeltime_forecast(
      h = .horiz,
      actual_data = .tag_dat
    )

  fore_plt <- fore_dat |>
    modeltime::plot_modeltime_forecast(
      .conf_interval_show = TRUE
    )

  attr(output, "model_fit")   <- model_fit_nnetar
  attr(output, "model_refit") <- model_refit_nnetar
  attr(output, "forecast")    <- fore_dat
  attr(output, "plot")        <- fore_plt

  return(output)

}


#' forecast_tbats
#'
#' @param .tag_dat A time series with `date` and `value` cols.
#' @param .assess The number of samples used for each assessment resample.
#' @param .horiz The forecast horizon.
#' @param .seasonal_period_1 (required) The primary seasonal frequency. Uses
#' "auto" by default. A character phrase of "auto" or time-based phrase of "2
#' weeks" can be used if a date or date-time variable is provided.
#' @param .seasonal_period_2 (optional) A second seasonal frequency. Is NULL
#' by default. A character phrase of "auto" or time-based phrase of "2 weeks"
#' can be used if a date or date-time variable is provided.
#' @param .seasonal_period_3 (optional) A third seasonal frequency. Is NULL by
#' default. A character phrase of "auto" or time-based phrase of "2 weeks" can
#' be used if a date or date-time variable is provided.
#'
#' @return A `parsnip` (BATS) model object.
#' @export
#'
forecast_tbats <- function(
    .tag_dat,
    .assess = 1,
    .horiz  = 1,
    .seasonal_period_1 = "auto",
    .seasonal_period_2 = NULL,
    .seasonal_period_3 = NULL
) {

  splits <- timetk::time_series_split(
    data       = .tag_dat,
    date_var   = date,
    assess     = .assess,
    cumulative = TRUE
  )

  model_fit_tbats <- modeltime::seasonal_reg(
    seasonal_period_1 = .seasonal_period_1,
    seasonal_period_2 = .seasonal_period_2,
    seasonal_period_3 = .seasonal_period_3
  ) |>
    parsnip::set_engine("tbats") |>
    parsnip::fit(value ~ date, rsample::training(splits))

  output <- calibrate_and_plot(model_fit_tbats, .splits = splits,
                               .actual_data = .tag_dat)

  model_refit_tbats <- output$calibration |>
    modeltime::modeltime_refit(data = .tag_dat)

  fore_dat <- model_refit_tbats |>
    modeltime::modeltime_forecast(
      h = .horiz,
      actual_data = .tag_dat
    )

  fore_plt <- fore_dat |>
    modeltime::plot_modeltime_forecast(
      .conf_interval_show = TRUE
    )

  attr(output, "model_fit")   <- model_fit_tbats
  attr(output, "model_refit") <- model_refit_tbats
  attr(output, "forecast")    <- fore_dat
  attr(output, "plot")        <- fore_plt

  return(output)

}


#' forecast_stlm
#'
#' @param .tag_dat A time series with `date` and `value` cols.
#' @param .assess The number of samples used for each assessment resample.
#' @param .horiz The forecast horizon.
#' @param .seasonal_period_1 (required) The primary seasonal frequency. Uses
#' "auto" by default. A character phrase of "auto" or time-based phrase of "2
#' weeks" can be used if a date or date-time variable is provided.
#' @param .seasonal_period_2 (optional) A second seasonal frequency. Is NULL
#' by default. A character phrase of "auto" or time-based phrase of "2 weeks"
#' can be used if a date or date-time variable is provided.
#' @param .seasonal_period_3 (optional) A third seasonal frequency. Is NULL by
#' default. A character phrase of "auto" or time-based phrase of "2 weeks" can
#' be used if a date or date-time variable is provided.
#' @param .algo A character string for the software that should be used to fit
#' the model, "ets" or "arima".
#'
#' @return A `parsnip` (STLM) model object.
#' @export
#'
forecast_stlm <- function(
    .tag_dat,
    .assess            = 1,
    .horiz             = 1,
    .seasonal_period_1 = "auto",
    .seasonal_period_2 = NULL,
    .seasonal_period_3 = NULL,
    .algo              = "ets"
) {

  splits <- timetk::time_series_split(
    data       = .tag_dat,
    date_var   = date,
    assess     = .assess,
    cumulative = TRUE
  )

  suffix <- switch (.algo,
    "ets" = "ets",
    "arima"
  )

  engine <- paste0("stlm_", suffix)

  model_fit_stlm <- modeltime::seasonal_reg(
    seasonal_period_1 = .seasonal_period_1,
    seasonal_period_2 = .seasonal_period_2,
    seasonal_period_3 = .seasonal_period_3
  ) |>
    parsnip::set_engine(engine) |>
    parsnip::fit(value ~ date, rsample::training(splits))

  output <- calibrate_and_plot(model_fit_stlm, .splits = splits,
                               .actual_data = .tag_dat)

  model_refit_stlm <- output$calibration |>
    modeltime::modeltime_refit(data = .tag_dat)

  fore_dat <- model_refit_stlm |>
    modeltime::modeltime_forecast(
      h = .horiz,
      actual_data = .tag_dat
    )

  fore_plt <- fore_dat |>
    modeltime::plot_modeltime_forecast(
      .conf_interval_show = TRUE
    )

  attr(output, "model_fit")   <- model_fit_stlm
  attr(output, "model_refit") <- model_refit_stlm
  attr(output, "forecast")    <- fore_dat
  attr(output, "plot")        <- fore_plt

  return(output)

}
# GENERATED BY RFOLD: DO NOT EDIT BY HAND ####
